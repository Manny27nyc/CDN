From ad2881d11c81488b569123158acece86f01e8e08 Mon Sep 17 00:00:00 2001
From: media <media@localhost.localdomain>
Date: Wed, 4 Dec 2019 22:05:33 +0800
Subject: [PATCH] Add the "-thread-count" parameter support

Signed-off-by: Zhizhen Tang <zhizhen.tang@intel.com>
---
 Config/Sample.cfg                                  |   1 +
 Source/API/EbSvtAv1Enc.h                           |   6 +
 Source/App/EncApp/EbAppConfig.c                    |   4 +
 Source/App/EncApp/EbAppConfig.h                    |   1 +
 Source/App/EncApp/EbAppContext.c                   |  13 +
 Source/Lib/Encoder/Codec/EbEncHandle.c             |  42 +-
 ...bility-for-ffmpeg-to-run-svt-av1-with-svt.patch | 621 +++++++++++++++++++++
 ...TCH-Add-ability-for-ffmpeg-to-run-svt-av1.patch | 621 +++++++++++++++++++++
 8 files changed, 1299 insertions(+), 10 deletions(-)
 create mode 100644 ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1-with-svt.patch
 create mode 100644 ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1.patch

diff --git a/Config/Sample.cfg b/Config/Sample.cfg
index ef221b9..4b2d2f6 100644
--- a/Config/Sample.cfg
+++ b/Config/Sample.cfg
@@ -80,6 +80,7 @@ HmeLevel2SearchAreaInHeight     : 1  1          # Array containing search area h
 AsmType                         : 1             # Assembly instruction set (0: Lowest optimization available, 1: Highest optimization available)
 LogicalProcessors               : 0             # The number of logical processor which encoder threads run on [0-N] (N is maximum number of logical processor)
 TargetSocket                    : -1            # For dual socket systems, this can specify which socket the encoder runs on (-1=Both Sockets, 0=Socket 0, 1=Socket 1)
+ThreadCount                     : 0             # The number of threads to get created and run [0-N] (0: Auto, 96: Min)
 #====================== Rate Control ===============================
 RateControlMode                 : 0             # Rate control mode (0: OFF(CQP), 1: ABR, 2: VBR, 3: CVBR)
 TargetBitRate                   : 500000        # Target Bit Rate (in bits per second)
diff --git a/Source/API/EbSvtAv1Enc.h b/Source/API/EbSvtAv1Enc.h
index dc18642..701c51a 100644
--- a/Source/API/EbSvtAv1Enc.h
+++ b/Source/API/EbSvtAv1Enc.h
@@ -24,6 +24,9 @@ extern "C" {
 #define EB_HME_SEARCH_AREA_COLUMN_MAX_COUNT         2
 #define EB_HME_SEARCH_AREA_ROW_MAX_COUNT            2
 
+#define EB_THREAD_COUNT_MIN_CORE                   48
+#define EB_THREAD_COUNT_FACTOR                      2
+
 #define MAX_ENC_PRESET                              8
 
 #define EB_BUFFERFLAG_EOS           0x00000001  // signals the last packet of the stream
@@ -415,6 +418,9 @@ typedef struct EbSvtAv1EncConfiguration
      * OS thread scheduler. */
     uint32_t                logical_processors;
 
+    /* The total number of working threads to create. */
+    uint32_t                threadCount;
+
     /* Target socket to run on. For dual socket systems, this can specify which
      * socket the encoder runs on.
      *
diff --git a/Source/App/EncApp/EbAppConfig.c b/Source/App/EncApp/EbAppConfig.c
index 5e7f59a..ebf7c03 100644
--- a/Source/App/EncApp/EbAppConfig.c
+++ b/Source/App/EncApp/EbAppConfig.c
@@ -121,6 +121,7 @@
 #define THREAD_MGMNT                    "-lp"
 #define TARGET_SOCKET                   "-ss"
 #define UNRESTRICTED_MOTION_VECTOR      "-umv"
+#define THREAD_COUNT                    "-thread-count"
 #define CONFIG_FILE_COMMENT_CHAR    '#'
 #define CONFIG_FILE_NEWLINE_CHAR    '\n'
 #define CONFIG_FILE_RETURN_CHAR     '\r'
@@ -316,6 +317,7 @@ static void SetAsmType                          (const char *value, EbConfig *cf
 static void SetLogicalProcessors                (const char *value, EbConfig *cfg)  {cfg->logical_processors         = (uint32_t)strtoul(value, NULL, 0);};
 static void SetTargetSocket                     (const char *value, EbConfig *cfg)  {cfg->target_socket              = (int32_t)strtol(value, NULL, 0);};
 static void SetUnrestrictedMotionVector         (const char *value, EbConfig *cfg)  {cfg->unrestricted_motion_vector = (EbBool)strtol(value, NULL, 0);};
+static void SetThreadCount                      (const char *value, EbConfig *cfg)  {cfg->threadCount                = (uint32_t)strtoul(value, NULL, 0);};
 
 static void SetSquareWeight                     (const char *value, EbConfig *cfg)  {cfg->sq_weight                  = (uint64_t)strtoul(value, NULL, 0);
         if (cfg->sq_weight == 0)
@@ -448,6 +450,7 @@ config_entry_t config_entry[] = {
     { SINGLE_INPUT, CONSTRAINED_INTRA_ENABLE_TOKEN, "ConstrainedIntra", SetEnableConstrainedIntra},
     // Thread Management
     { SINGLE_INPUT, THREAD_MGMNT, "logicalProcessors", SetLogicalProcessors },
+    { SINGLE_INPUT, THREAD_COUNT, "ThreadCount", SetThreadCount },
     { SINGLE_INPUT, TARGET_SOCKET, "TargetSocket", SetTargetSocket },
     // Optional Features
     { SINGLE_INPUT, UNRESTRICTED_MOTION_VECTOR, "UnrestrictedMotionVector", SetUnrestrictedMotionVector },
@@ -507,6 +510,7 @@ void eb_config_ctor(EbConfig *config_ptr)
     config_ptr->use_qp_file                          = EB_FALSE;
     config_ptr->look_ahead_distance                  = (uint32_t)~0;
     config_ptr->target_bit_rate                        = 7000000;
+    config_ptr->threadCount                          = 0;
     config_ptr->max_qp_allowed                       = 63;
     config_ptr->min_qp_allowed                       = 10;
 
diff --git a/Source/App/EncApp/EbAppConfig.h b/Source/App/EncApp/EbAppConfig.h
index 450fb4d..9a5e764 100644
--- a/Source/App/EncApp/EbAppConfig.h
+++ b/Source/App/EncApp/EbAppConfig.h
@@ -361,6 +361,7 @@ typedef struct EbConfig
     uint32_t                channel_id;
     uint32_t                active_channel_count;
     uint32_t                logical_processors;
+    uint32_t                threadCount;
     int32_t                 target_socket;
     EbBool                  stop_encoder;         // to signal CTRL+C Event, need to stop encoding.
 
diff --git a/Source/App/EncApp/EbAppContext.c b/Source/App/EncApp/EbAppContext.c
index 3789aef..af60bf7 100644
--- a/Source/App/EncApp/EbAppContext.c
+++ b/Source/App/EncApp/EbAppContext.c
@@ -226,6 +226,19 @@ EbErrorType CopyConfigurationParameters(
     callback_data->eb_enc_parameters.logical_processors = config->logical_processors;
     callback_data->eb_enc_parameters.target_socket = config->target_socket;
     callback_data->eb_enc_parameters.unrestricted_motion_vector = config->unrestricted_motion_vector;
+
+    if ((config->threadCount > 0) && (config->threadCount < EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_FACTOR)) {
+        callback_data->eb_enc_parameters.threadCount = EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_FACTOR;
+        printf("\nWarning: the thread count %u is set too small and is forced to the min value %u\n",
+                config->threadCount, callback_data->eb_enc_parameters.threadCount);
+    } else {
+        callback_data->eb_enc_parameters.threadCount = (config->threadCount + EB_THREAD_COUNT_MIN_CORE - 1)
+                                                    / EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_MIN_CORE;
+        if (callback_data->eb_enc_parameters.threadCount != config->threadCount)
+            printf("\nInformation: the thread count %u is rounded to %u\n",
+                    config->threadCount, callback_data->eb_enc_parameters.threadCount);
+    }
+
     callback_data->eb_enc_parameters.recon_enabled = config->recon_file ? EB_TRUE : EB_FALSE;
     // --- start: ALTREF_FILTERING_SUPPORT
     callback_data->eb_enc_parameters.enable_altrefs  = (EbBool)config->enable_altrefs;
diff --git a/Source/Lib/Encoder/Codec/EbEncHandle.c b/Source/Lib/Encoder/Codec/EbEncHandle.c
index e3853ea..1a6a909 100644
--- a/Source/Lib/Encoder/Codec/EbEncHandle.c
+++ b/Source/Lib/Encoder/Codec/EbEncHandle.c
@@ -375,6 +375,10 @@ EbErrorType load_default_buffer_configuration_settings(
 
     unsigned int lp_count   = GetNumProcessors();
     unsigned int core_count = lp_count;
+
+    unsigned int totalThreadCount;
+    unsigned int threadUnit;
+
 #if defined(_WIN32) || defined(__linux__)
     if (sequence_control_set_ptr->static_config.target_socket != -1)
         core_count /= num_groups;
@@ -396,6 +400,24 @@ EbErrorType load_default_buffer_configuration_settings(
         sequence_control_set_ptr->static_config.logical_processors > lp_count / num_groups)
         core_count = lp_count;
 #endif
+
+    // Thread count computation
+    if (sequence_control_set_ptr->static_config.threadCount != 0)
+        totalThreadCount = sequence_control_set_ptr->static_config.threadCount;
+    else
+        totalThreadCount = core_count * EB_THREAD_COUNT_FACTOR;
+
+    if (totalThreadCount < EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_FACTOR) {
+        core_count = EB_THREAD_COUNT_MIN_CORE;
+        totalThreadCount = core_count * EB_THREAD_COUNT_FACTOR;
+    }
+
+    if (totalThreadCount % EB_THREAD_COUNT_MIN_CORE) {
+        totalThreadCount = (totalThreadCount + EB_THREAD_COUNT_MIN_CORE - 1)
+                           / EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_MIN_CORE;
+    }
+    threadUnit = totalThreadCount / EB_THREAD_COUNT_MIN_CORE;
+
     int32_t return_ppcs = set_parent_pcs(&sequence_control_set_ptr->static_config,
                     core_count, sequence_control_set_ptr->input_resolution);
     if (return_ppcs == -1)
@@ -484,16 +506,17 @@ EbErrorType load_default_buffer_configuration_settings(
     sequence_control_set_ptr->rest_fifo_init_count                        = 300;
     //#====================== Processes number ======================
     sequence_control_set_ptr->total_process_init_count                    = 0;
+    sequence_control_set_ptr->total_process_init_count += 6; // single processes count
     if (core_count > 1){
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->picture_analysis_process_init_count            = MAX(MIN(15, core_count >> 1), core_count / 6));
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->motion_estimation_process_init_count =  MAX(MIN(20, core_count >> 1), core_count / 3));//1);//
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->source_based_operations_process_init_count     = MAX(MIN(3, core_count >> 1), core_count / 12));
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->mode_decision_configuration_process_init_count = MAX(MIN(3, core_count >> 1), core_count / 12));
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->enc_dec_process_init_count                     = MAX(MIN(40, core_count >> 1), core_count));
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->entropy_coding_process_init_count              = MAX(MIN(3, core_count >> 1), core_count / 12));
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->dlf_process_init_count                         = MAX(MIN(40, core_count >> 1), core_count));
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->cdef_process_init_count                        = MAX(MIN(40, core_count >> 1), core_count));
-        sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->rest_process_init_count                        = MAX(MIN(40, core_count >> 1), core_count));
+		sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->picture_analysis_process_init_count = threadUnit * 3;
+        sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->motion_estimation_process_init_count = threadUnit * 8;
+        sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->source_based_operations_process_init_count = threadUnit * 2;
+		sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->mode_decision_configuration_process_init_count = threadUnit * 2;
+		sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->entropy_coding_process_init_count = threadUnit * 2;
+		sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->enc_dec_process_init_count = (totalThreadCount - sequence_control_set_ptr->total_process_init_count) / 4;
+        sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->dlf_process_init_count = sequence_control_set_ptr->enc_dec_process_init_count;
+        sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->cdef_process_init_count = sequence_control_set_ptr->enc_dec_process_init_count;
+        sequence_control_set_ptr->total_process_init_count += sequence_control_set_ptr->rest_process_init_count = sequence_control_set_ptr->enc_dec_process_init_count;
     }else{
         sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->picture_analysis_process_init_count            = 1);
         sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->motion_estimation_process_init_count           = 1);
@@ -506,7 +529,6 @@ EbErrorType load_default_buffer_configuration_settings(
         sequence_control_set_ptr->total_process_init_count += (sequence_control_set_ptr->rest_process_init_count                        = 1);
     }
 
-    sequence_control_set_ptr->total_process_init_count += 6; // single processes count
     printf("Number of logical cores available: %u\nNumber of PPCS %u\n", core_count, sequence_control_set_ptr->picture_control_set_pool_init_count);
 
     return return_error;
diff --git a/ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1-with-svt.patch b/ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1-with-svt.patch
new file mode 100644
index 0000000..8e1a270
--- /dev/null
+++ b/ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1-with-svt.patch
@@ -0,0 +1,621 @@
+From 32c16596bb358d98fed7fbfa19d317eeba2c4d4f Mon Sep 17 00:00:00 2001
+From: Zhizhen Tang <zhizhen.tang@intel.com>
+Date: Mon, 4 Nov 2019 10:38:50 +0800
+Subject: [PATCH] [PATCH] Add ability for ffmpeg to run svt-av1 with svt-hevc
+Cc: zhong.li@intel.com
+
+Change-Id: I37ee5414fdd99e0b3f112a6e5ede166f3e48d819
+Signed-off-by: Daryl Seah <daryl.seah@intel.com>
+Signed-off-by: Jing SUN <jing.a.sun@intel.com>
+Signed-off-by: ZhiZhen Tang <zhizhen.tang@intel.com>
+Signed-off-by: Zhong Li <zhong.li@intel.com>
+---
+ configure               |   4 +
+ libavcodec/Makefile     |   1 +
+ libavcodec/allcodecs.c  |   1 +
+ libavcodec/libsvt_av1.c | 533 ++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 539 insertions(+)
+ create mode 100644 libavcodec/libsvt_av1.c
+
+diff --git a/configure b/configure
+index dc5f74f..3e98046 100755
+--- a/configure
++++ b/configure
+@@ -265,6 +265,7 @@ External library support:
+   --enable-libsrt          enable Haivision SRT protocol via libsrt [no]
+   --enable-libssh          enable SFTP protocol via libssh [no]
+   --enable-libsvthevc      enable HEVC encoding via svt [no]
++  --enable-libsvtav1       enable AV1 encoding via svt [no]
+   --enable-libtensorflow   enable TensorFlow as a DNN module backend
+                            for DNN based filters like sr [no]
+   --enable-libtesseract    enable Tesseract, needed for ocr filter [no]
+@@ -1795,6 +1796,7 @@ EXTERNAL_LIBRARY_LIST="
+     libsrt
+     libssh
+     libsvthevc
++    libsvtav1
+     libtensorflow
+     libtesseract
+     libtheora
+@@ -3194,6 +3196,7 @@ libspeex_decoder_deps="libspeex"
+ libspeex_encoder_deps="libspeex"
+ libspeex_encoder_select="audio_frame_queue"
+ libsvt_hevc_encoder_deps="libsvthevc"
++libsvt_av1_encoder_deps="libsvtav1"
+ libtheora_encoder_deps="libtheora"
+ libtwolame_encoder_deps="libtwolame"
+ libvo_amrwbenc_encoder_deps="libvo_amrwbenc"
+@@ -6267,6 +6270,7 @@ enabled libssh            && require_pkg_config libssh libssh libssh/sftp.h sftp
+ enabled libspeex          && require_pkg_config libspeex speex speex/speex.h speex_decoder_init
+ enabled libsrt            && require_pkg_config libsrt "srt >= 1.3.0" srt/srt.h srt_socket
+ enabled libsvthevc        && require_pkg_config libsvthevc SvtHevcEnc EbApi.h EbInitHandle
++enabled libsvtav1         && require_pkg_config libsvtav1 SvtAv1Enc EbSvtAv1Enc.h eb_init_handle
+ enabled libtensorflow     && require libtensorflow tensorflow/c/c_api.h TF_Version -ltensorflow
+ enabled libtesseract      && require_pkg_config libtesseract tesseract tesseract/capi.h TessBaseAPICreate
+ enabled libtheora         && require libtheora theora/theoraenc.h th_info_init -ltheoraenc -ltheoradec -logg
+diff --git a/libavcodec/Makefile b/libavcodec/Makefile
+index d39f568..c500f3d 100644
+--- a/libavcodec/Makefile
++++ b/libavcodec/Makefile
+@@ -992,6 +992,7 @@ OBJS-$(CONFIG_LIBSHINE_ENCODER)           += libshine.o
+ OBJS-$(CONFIG_LIBSPEEX_DECODER)           += libspeexdec.o
+ OBJS-$(CONFIG_LIBSPEEX_ENCODER)           += libspeexenc.o
+ OBJS-$(CONFIG_LIBSVT_HEVC_ENCODER)        += libsvt_hevc.o
++OBJS-$(CONFIG_LIBSVT_AV1_ENCODER)         += libsvt_av1.o
+ OBJS-$(CONFIG_LIBTHEORA_ENCODER)          += libtheoraenc.o
+ OBJS-$(CONFIG_LIBTWOLAME_ENCODER)         += libtwolame.o
+ OBJS-$(CONFIG_LIBVO_AMRWBENC_ENCODER)     += libvo-amrwbenc.o
+diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
+index d8788a7..db1b1b2 100644
+--- a/libavcodec/allcodecs.c
++++ b/libavcodec/allcodecs.c
+@@ -708,6 +708,7 @@ extern AVCodec ff_libshine_encoder;
+ extern AVCodec ff_libspeex_encoder;
+ extern AVCodec ff_libspeex_decoder;
+ extern AVCodec ff_libsvt_hevc_encoder;
++extern AVCodec ff_libsvt_av1_encoder;
+ extern AVCodec ff_libtheora_encoder;
+ extern AVCodec ff_libtwolame_encoder;
+ extern AVCodec ff_libvo_amrwbenc_encoder;
+diff --git a/libavcodec/libsvt_av1.c b/libavcodec/libsvt_av1.c
+new file mode 100644
+index 0000000..7bed66c
+--- /dev/null
++++ b/libavcodec/libsvt_av1.c
+@@ -0,0 +1,533 @@
++/*
++* Scalable Video Technology for AV1 encoder library plugin
++*
++* Copyright (c) 2018 Intel Corporation
++*
++* This file is part of FFmpeg.
++*
++* FFmpeg is free software; you can redistribute it and/or
++* modify it under the terms of the GNU Lesser General Public
++* License as published by the Free Software Foundation; either
++* version 2.1 of the License, or (at your option) any later version.
++*
++* FFmpeg is distributed in the hope that it will be useful,
++* but WITHOUT ANY WARRANTY; without even the implied warranty of
++* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++* Lesser General Public License for more details.
++*
++* You should have received a copy of the GNU Lesser General Public
++* License along with this program; if not, write to the Free Software
++* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++*/
++
++#include <stdint.h>
++#include "EbSvtAv1ErrorCodes.h"
++#include "EbSvtAv1Enc.h"
++
++#include "libavutil/common.h"
++#include "libavutil/frame.h"
++#include "libavutil/opt.h"
++#include "libavutil/pixdesc.h"
++#include "libavutil/avassert.h"
++
++#include "internal.h"
++#include "avcodec.h"
++
++typedef enum eos_status {
++    EOS_NOT_REACHED = 0,
++    EOS_SENT,
++    EOS_RECEIVED
++}EOS_STATUS;
++
++typedef struct SvtContext {
++    AVClass     *class;
++
++    EbSvtAv1EncConfiguration    enc_params;
++    EbComponentType            *svt_handle;
++
++    EbBufferHeaderType         *in_buf;
++    int                         raw_size;
++
++    EOS_STATUS eos_flag;
++
++    // User options.
++    int hierarchical_level;
++    int la_depth;
++    int enc_mode;
++    int rc_mode;
++    int scd;
++    int qp;
++
++    int forced_idr;
++
++    int tier;
++    int level;
++    int profile;
++
++    int base_layer_switch_mode;
++    int thread_count;
++} SvtContext;
++
++static const struct {
++    EbErrorType    eb_err;
++    int            av_err;
++    const char     *desc;
++} svt_errors[] = {
++    { EB_ErrorNone,                             0,              "success"                   },
++    { EB_ErrorInsufficientResources,      AVERROR(ENOMEM),      "insufficient resources"    },
++    { EB_ErrorUndefined,                  AVERROR(EINVAL),      "undefined error"           },
++    { EB_ErrorInvalidComponent,           AVERROR(EINVAL),      "invalid component"         },
++    { EB_ErrorBadParameter,               AVERROR(EINVAL),      "bad parameter"             },
++    { EB_ErrorDestroyThreadFailed,        AVERROR_EXTERNAL,     "failed to destory thread"  },
++    { EB_ErrorSemaphoreUnresponsive,      AVERROR_EXTERNAL,     "semaphore unresponsive"    },
++    { EB_ErrorDestroySemaphoreFailed,     AVERROR_EXTERNAL,     "semaphore unresponsive"    },
++    { EB_ErrorCreateMutexFailed,          AVERROR_EXTERNAL,     "failed to creat mutex"     },
++    { EB_ErrorMutexUnresponsive,          AVERROR_EXTERNAL,     "mutex unresponsive"        },
++    { EB_ErrorDestroyMutexFailed,         AVERROR_EXTERNAL,     "failed to destory muxtex"  },
++    { EB_NoErrorEmptyQueue,               AVERROR(EAGAIN),      "empty queue"               },
++};
++
++static int svt_map_error(EbErrorType eb_err, const char **desc)
++{
++    int i;
++
++    av_assert0(desc);
++    for (i = 0; i < FF_ARRAY_ELEMS(svt_errors); i++) {
++        if (svt_errors[i].eb_err == eb_err) {
++            *desc = svt_errors[i].desc;
++            return svt_errors[i].av_err;
++        }
++    }
++    *desc = "unknown error";
++    return AVERROR_UNKNOWN;
++}
++
++static int svt_print_error(void *log_ctx, EbErrorType err,
++                           const char *error_string)
++{
++    const char *desc;
++    int ret;
++    ret = svt_map_error(err, &desc);
++    av_log(log_ctx, AV_LOG_ERROR, "%s: %s (0x%x)\n", error_string, desc, err);
++    return ret;
++}
++
++static void free_buffer(SvtContext *svt_enc)
++{
++    if (svt_enc->in_buf) {
++        EbSvtIOFormat *in_data = (EbSvtIOFormat *)svt_enc->in_buf->p_buffer;
++        av_freep(&in_data);
++        av_freep(&svt_enc->in_buf);
++    }
++}
++
++static int alloc_buffer(EbSvtAv1EncConfiguration *config, SvtContext *svt_enc)
++{
++    const int    pack_mode_10bit   =
++        (config->encoder_bit_depth > 8) && (config->compressed_ten_bit_format == 0) ? 1 : 0;
++    const size_t luma_size_8bit    =
++        config->source_width * config->source_height * (1 << pack_mode_10bit);
++    const size_t luma_size_10bit   =
++        (config->encoder_bit_depth > 8 && pack_mode_10bit == 0) ? luma_size_8bit : 0;
++
++    EbSvtIOFormat *in_data;
++
++    svt_enc->raw_size = (luma_size_8bit + luma_size_10bit) * 3 / 2;
++
++    // allocate buffer for in and out
++    svt_enc->in_buf           = av_mallocz(sizeof(*svt_enc->in_buf));
++    if (!svt_enc->in_buf)
++        return AVERROR(ENOMEM);
++
++    in_data  = av_mallocz(sizeof(*in_data));
++    if (!in_data)
++        return AVERROR(ENOMEM);
++    svt_enc->in_buf->p_buffer  = (unsigned char *)in_data;
++
++    svt_enc->in_buf->size        = sizeof(*svt_enc->in_buf);
++    svt_enc->in_buf->p_app_private  = NULL;
++
++    return 0;
++
++}
++
++static int config_enc_params(EbSvtAv1EncConfiguration *param,
++                             AVCodecContext *avctx)
++{
++    SvtContext *svt_enc = avctx->priv_data;
++    const AVPixFmtDescriptor *desc;
++    int ret;
++
++    param->source_width     = avctx->width;
++    param->source_height    = avctx->height;
++
++    desc = av_pix_fmt_desc_get(avctx->pix_fmt);
++    param->encoder_bit_depth = desc->comp[0].depth;
++    av_log(avctx, AV_LOG_DEBUG , "Encoder %d bits depth input\n", param->encoder_bit_depth);
++
++    if (desc->log2_chroma_w == 1 && desc->log2_chroma_h == 1)
++        param->encoder_color_format   = EB_YUV420;
++    else if (desc->log2_chroma_w == 1 && desc->log2_chroma_h == 0)
++        param->encoder_color_format   = EB_YUV422;
++    else if (!desc->log2_chroma_w && !desc->log2_chroma_h)
++        param->encoder_color_format   = EB_YUV444;
++    else {
++        av_log(avctx, AV_LOG_ERROR , "Unsupported pixel format\n");
++        return AVERROR(EINVAL);
++    }
++    av_log(avctx, AV_LOG_DEBUG , "Encoder color format is %d \n", param->encoder_color_format);
++
++    param->profile = svt_enc->profile;
++
++    if ((param->encoder_color_format == EB_YUV422 || param->encoder_bit_depth > 10)
++         && param->profile != PROFESSIONAL_PROFILE ) {
++        av_log(avctx, AV_LOG_WARNING, "Force to be professional profile \n");
++        param->profile = PROFESSIONAL_PROFILE;
++    } else if (param->encoder_color_format == EB_YUV444 && param->profile != HIGH_PROFILE) {
++        av_log(avctx, AV_LOG_WARNING, "Force to be high profile \n");
++        param->profile = HIGH_PROFILE;
++    }
++
++    // Update param from options
++    param->hierarchical_levels     = svt_enc->hierarchical_level;
++    param->enc_mode                = svt_enc->enc_mode;
++    param->tier                   = svt_enc->tier;
++    param->level                  = svt_enc->level;
++    param->rate_control_mode        = svt_enc->rc_mode;
++    param->scene_change_detection   = svt_enc->scd;
++    param->base_layer_switch_mode    = svt_enc->base_layer_switch_mode;
++    param->qp                     = svt_enc->qp;
++
++
++    param->target_bit_rate          = avctx->bit_rate;
++    if (avctx->gop_size > 0)
++        param->intra_period_length  = avctx->gop_size - 1;
++
++    if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {
++        param->frame_rate_numerator     = avctx->framerate.num;
++        param->frame_rate_denominator   = avctx->framerate.den * avctx->ticks_per_frame;
++    } else {
++        param->frame_rate_numerator     = avctx->time_base.den;
++        param->frame_rate_denominator   = avctx->time_base.num * avctx->ticks_per_frame;
++    }
++
++    if (param->rate_control_mode) {
++        param->max_qp_allowed       = avctx->qmax;
++        param->min_qp_allowed       = avctx->qmin;
++    }
++
++    param->intra_refresh_type       = svt_enc->forced_idr + 1;
++
++    if (svt_enc->la_depth != -1)
++        param->look_ahead_distance  = svt_enc->la_depth;
++
++    if ((svt_enc->thread_count > 0) &&
++        (svt_enc->thread_count < (EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_FACTOR))) {
++        param->threadCount = EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_FACTOR;
++        av_log(avctx, AV_LOG_WARNING, "Thread count is set too small, forced to %"PRId32"\n",
++               param->threadCount);
++    } else if (svt_enc->thread_count % EB_THREAD_COUNT_MIN_CORE) {
++        param->threadCount = (svt_enc->thread_count + EB_THREAD_COUNT_MIN_CORE - 1)
++                             / EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_MIN_CORE;
++        av_log(avctx, AV_LOG_DEBUG, "Thread count is rounded to %"PRId32"\n",
++               param->threadCount);
++    } else {
++        param->threadCount = svt_enc->thread_count;
++    }
++
++    return 0;
++}
++
++static void read_in_data(const AVFrame *frame,
++                         EbBufferHeaderType *header_ptr)
++{
++    EbSvtIOFormat *in_data = (EbSvtIOFormat *)header_ptr->p_buffer;
++    const AVPixFmtDescriptor *desc;
++    int i, bytes_shift, plane_h;
++
++    desc = av_pix_fmt_desc_get(frame->format);
++    bytes_shift = desc->comp[0].depth > 8 ? 1 : 0;
++
++    in_data->luma = frame->data[0];
++    in_data->cb   = frame->data[1];
++    in_data->cr   = frame->data[2];
++
++    in_data->y_stride  = AV_CEIL_RSHIFT(frame->linesize[0], bytes_shift);
++    in_data->cb_stride = AV_CEIL_RSHIFT(frame->linesize[1], bytes_shift);
++    in_data->cr_stride = AV_CEIL_RSHIFT(frame->linesize[2], bytes_shift);
++
++    for (i = 0; i < desc->nb_components; i++) {
++        plane_h = frame->height;
++        if (i > 0)
++            plane_h = AV_CEIL_RSHIFT(plane_h, desc->log2_chroma_h);
++        header_ptr->n_filled_len += frame->linesize[i] * plane_h;
++    }
++}
++
++static av_cold int eb_enc_init(AVCodecContext *avctx)
++{
++    SvtContext   *svt_enc = avctx->priv_data;
++    EbErrorType svt_ret;
++    int ret;
++
++    svt_enc->eos_flag = EOS_NOT_REACHED;
++
++    svt_ret = eb_init_handle(&svt_enc->svt_handle, svt_enc, &svt_enc->enc_params);
++    if (svt_ret != EB_ErrorNone) {
++        return svt_print_error(avctx, svt_ret, "Error init encoder handle");
++    }
++
++    ret = config_enc_params(&svt_enc->enc_params, avctx);
++    if (ret < 0) {
++        av_log(avctx, AV_LOG_ERROR, "Error configure encoder parameters\n");
++        return ret;
++    }
++
++    svt_ret = eb_svt_enc_set_parameter(svt_enc->svt_handle, &svt_enc->enc_params);
++    if (svt_ret != EB_ErrorNone) {
++        return svt_print_error(avctx, svt_ret, "Error setting encoder parameters");
++    }
++
++    svt_ret = eb_init_encoder(svt_enc->svt_handle);
++    if (svt_ret != EB_ErrorNone) {
++        eb_deinit_handle(svt_enc->svt_handle);
++        svt_enc->svt_handle = NULL;
++        return svt_print_error(avctx, svt_ret, "Error init encoder");
++    }
++
++    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
++        EbBufferHeaderType *headerPtr = NULL;
++
++        svt_ret = eb_svt_enc_stream_header(svt_enc->svt_handle, &headerPtr);
++        if (svt_ret != EB_ErrorNone) {
++            return svt_print_error(avctx, svt_ret, "Error when build stream header");
++        }
++
++        avctx->extradata_size = headerPtr->n_filled_len;
++        avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
++        if (!avctx->extradata) {
++            av_log(avctx, AV_LOG_ERROR,
++                   "Cannot allocate AV1 header of size %d.\n", avctx->extradata_size);
++            return AVERROR(ENOMEM);
++        }
++
++        memcpy(avctx->extradata, headerPtr->p_buffer, avctx->extradata_size);
++
++        svt_ret = eb_svt_release_enc_stream_header(headerPtr);
++        if (svt_ret != EB_ErrorNone) {
++            return svt_print_error(avctx, svt_ret, "Error when destroy stream header");
++        }
++    }
++
++    ret = alloc_buffer(&svt_enc->enc_params, svt_enc);
++    if (ret < 0)
++        return ret;
++    return 0;
++
++}
++
++static int eb_send_frame(AVCodecContext *avctx, const AVFrame *frame)
++{
++    SvtContext           *svt_enc = avctx->priv_data;
++    EbBufferHeaderType  *headerPtr = svt_enc->in_buf;
++
++    if (!frame) {
++        EbBufferHeaderType headerPtrLast;
++        headerPtrLast.n_alloc_len   = 0;
++        headerPtrLast.n_filled_len  = 0;
++        headerPtrLast.n_tick_count  = 0;
++        headerPtrLast.p_app_private = NULL;
++        headerPtrLast.p_buffer     = NULL;
++        headerPtrLast.flags      = EB_BUFFERFLAG_EOS;
++
++        eb_svt_enc_send_picture(svt_enc->svt_handle, &headerPtrLast);
++        svt_enc->eos_flag = EOS_SENT;
++        av_log(avctx, AV_LOG_DEBUG, "Finish sending frames!!!\n");
++        return 0;
++    }
++
++    read_in_data(frame, headerPtr);
++
++    headerPtr->flags       = 0;
++    headerPtr->p_app_private  = NULL;
++    headerPtr->pts          = frame->pts;
++
++    eb_svt_enc_send_picture(svt_enc->svt_handle, headerPtr);
++
++    return 0;
++}
++
++static int eb_receive_packet(AVCodecContext *avctx, AVPacket *pkt)
++{
++    SvtContext  *svt_enc = avctx->priv_data;
++    EbBufferHeaderType *headerPtr;
++    EbErrorType svt_ret;
++    int ret = 0, pict_type;
++
++    if (svt_enc->eos_flag == EOS_RECEIVED)
++        return AVERROR_EOF;
++
++    if ((ret = ff_alloc_packet2(avctx, pkt, svt_enc->raw_size, 0)) < 0) {
++        av_log(avctx, AV_LOG_ERROR, "Failed to allocate output packet.\n");
++        return ret;
++    }
++    svt_ret = eb_svt_get_packet(svt_enc->svt_handle, &headerPtr, svt_enc->eos_flag);
++    if (svt_ret == EB_NoErrorEmptyQueue)
++        return AVERROR(EAGAIN);
++
++    memcpy(pkt->data, headerPtr->p_buffer, headerPtr->n_filled_len);
++    pkt->size = headerPtr->n_filled_len;
++    pkt->pts  = headerPtr->pts;
++    pkt->dts  = headerPtr->dts;
++    if (headerPtr->pic_type == EB_AV1_KEY_PICTURE) {
++        pkt->flags |= AV_PKT_FLAG_KEY;
++        pict_type = AV_PICTURE_TYPE_I;
++    } else if (headerPtr->pic_type == EB_AV1_INTRA_ONLY_PICTURE) {
++        pict_type = AV_PICTURE_TYPE_I;
++    } else if (headerPtr->pic_type == EB_AV1_INVALID_PICTURE) {
++        pict_type = AV_PICTURE_TYPE_NONE;
++    } else
++        pict_type = AV_PICTURE_TYPE_P;
++
++    if (headerPtr->pic_type == EB_AV1_NON_REF_PICTURE)
++        pkt->flags |= AV_PKT_FLAG_DISPOSABLE;
++
++    if (headerPtr->flags & EB_BUFFERFLAG_EOS)
++        svt_enc->eos_flag = EOS_RECEIVED;
++
++    ff_side_data_set_encoder_stats(pkt, headerPtr->qp * FF_QP2LAMBDA, NULL, 0, pict_type);
++
++    eb_svt_release_out_buffer(&headerPtr);
++
++    return ret;
++}
++
++static av_cold int eb_enc_close(AVCodecContext *avctx)
++{
++    SvtContext *svt_enc = avctx->priv_data;
++
++    if (svt_enc) {
++        if (svt_enc->svt_handle) {
++            eb_deinit_encoder(svt_enc->svt_handle);
++            eb_deinit_handle(svt_enc->svt_handle);
++        }
++
++        free_buffer(svt_enc);
++        svt_enc = NULL;
++    }
++    return 0;
++}
++
++#define OFFSET(x) offsetof(SvtContext, x)
++#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
++static const AVOption options[] = {
++    { "hielevel", "Hierarchical prediction levels setting", OFFSET(hierarchical_level),
++      AV_OPT_TYPE_INT, { .i64 = 4 }, 3, 4, VE , "hielevel"},
++        { "3level", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 3 },  INT_MIN, INT_MAX, VE, "hielevel" },
++        { "4level", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 4 },  INT_MIN, INT_MAX, VE, "hielevel" },
++
++    { "la_depth", "Look ahead distance [0, 120]", OFFSET(la_depth),
++      AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 120, VE },
++
++    { "preset", "Encoding preset [0, 8]",
++      OFFSET(enc_mode), AV_OPT_TYPE_INT, { .i64 = MAX_ENC_PRESET }, 0, MAX_ENC_PRESET, VE },
++
++    { "profile", "Set profile restrictions", OFFSET(profile), AV_OPT_TYPE_INT, { .i64 = MAIN_PROFILE}, MAIN_PROFILE, PROFESSIONAL_PROFILE, VE, "profile" },
++    { "main" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MAIN_PROFILE}, INT_MIN, INT_MAX,     VE, "profile" },
++    { "high" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = HIGH_PROFILE}, INT_MIN, INT_MAX,     VE, "profile" },
++    { "professional", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = PROFESSIONAL_PROFILE }, INT_MIN, INT_MAX,     VE, "profile" },
++
++    { "tier", "Set tier (general_tier_flag)", OFFSET(tier),
++      AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE, "tier" },
++        { "main", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, VE, "tier" },
++        { "high", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, VE, "tier" },
++
++    { "level", "Set level (level_idc)", OFFSET(level),
++      AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 0x1f, VE, "level" },
++
++#define LEVEL(name, value) name, NULL, 0, AV_OPT_TYPE_CONST, \
++      { .i64 = value }, 0, 0, VE, "level"
++        { LEVEL("2.0", 20) },
++        { LEVEL("2.1", 21) },
++        { LEVEL("2.2", 22) },
++        { LEVEL("2.3", 23) },
++        { LEVEL("3.0", 30) },
++        { LEVEL("3.1", 31) },
++        { LEVEL("3.2", 32) },
++        { LEVEL("3.3", 33) },
++        { LEVEL("4.0", 40) },
++        { LEVEL("4.1", 41) },
++        { LEVEL("4.2", 42) },
++        { LEVEL("4.3", 43) },
++        { LEVEL("5.0", 50) },
++        { LEVEL("5.1", 51) },
++        { LEVEL("5.2", 52) },
++        { LEVEL("5.3", 53) },
++        { LEVEL("6.0", 60) },
++        { LEVEL("6.1", 61) },
++        { LEVEL("6.2", 62) },
++        { LEVEL("6.3", 63) },
++        { LEVEL("7.0", 70) },
++        { LEVEL("7.1", 71) },
++        { LEVEL("7.2", 72) },
++        { LEVEL("7.3", 73) },
++#undef LEVEL
++
++    { "rc", "Bit rate control mode", OFFSET(rc_mode),
++      AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 3, VE , "rc"},
++        { "cqp", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 },  INT_MIN, INT_MAX, VE, "rc" },
++        { "vbr", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 },  INT_MIN, INT_MAX, VE, "rc" },
++        { "cvbr", NULL, 0, AV_OPT_TYPE_CONST,{ .i64 = 3 },  INT_MIN, INT_MAX, VE, "rc" },
++
++    { "qp", "QP value for intra frames", OFFSET(qp),
++      AV_OPT_TYPE_INT, { .i64 = 50 }, 0, 63, VE },
++
++    { "sc_detection", "Scene change detection", OFFSET(scd),
++      AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE },
++
++    { "bl_mode", "Random Access Prediction Structure type setting", OFFSET(base_layer_switch_mode),
++      AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE },
++
++    { "forced-idr", "If forcing keyframes, force them as IDR frames.", OFFSET(forced_idr),
++      AV_OPT_TYPE_BOOL,   { .i64 = 0 }, 0, 1, VE },
++
++    { "thread_count", "Number of threads [0: Auto, 96: Min]", OFFSET(thread_count),
++      AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, VE },
++
++    {NULL},
++};
++
++static const AVClass class = {
++    .class_name = "libsvt_av1",
++    .item_name  = av_default_item_name,
++    .option     = options,
++    .version    = LIBAVUTIL_VERSION_INT,
++};
++
++static const AVCodecDefault eb_enc_defaults[] = {
++    { "b",         "7M"    },
++    { "g",         "-2"    },
++    { "qmin",      "0"     },
++    { "qmax",      "63"    },
++    { NULL },
++};
++
++AVCodec ff_libsvt_av1_encoder = {
++    .name           = "libsvt_av1",
++    .long_name      = NULL_IF_CONFIG_SMALL("SVT-AV1(Scalable Video Technology for AV1) encoder"),
++    .priv_data_size = sizeof(SvtContext),
++    .type           = AVMEDIA_TYPE_VIDEO,
++    .id             = AV_CODEC_ID_AV1,
++    .init           = eb_enc_init,
++    .send_frame     = eb_send_frame,
++    .receive_packet = eb_receive_packet,
++    .close          = eb_enc_close,
++    .capabilities   = AV_CODEC_CAP_DELAY,
++    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P,
++                                                    AV_PIX_FMT_YUV420P10,
++                                                    AV_PIX_FMT_NONE },
++    .priv_class     = &class,
++    .defaults       = eb_enc_defaults,
++    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
++    .wrapper_name   = "libsvt_av1",
++};
+-- 
+2.17.1
+
diff --git a/ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1.patch b/ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1.patch
new file mode 100644
index 0000000..58e4020
--- /dev/null
+++ b/ffmpeg_plugin/0001-PATCH-Add-ability-for-ffmpeg-to-run-svt-av1.patch
@@ -0,0 +1,621 @@
+From 73473faf09872957f7dc370d9427d632441b5788 Mon Sep 17 00:00:00 2001
+From: Zhizhen Tang <zhizhen.tang@intel.com>
+Date: Mon, 4 Nov 2019 10:47:19 +0800
+Subject: [PATCH] [PATCH] Add ability for ffmpeg to run svt-av1
+Cc: zhong.li@intel.com
+
+Change-Id: I37ee5414fdd99e0b3f112a6e5ede166f3e48d819
+Signed-off-by: Daryl Seah <daryl.seah@intel.com>
+Signed-off-by: Jing SUN <jing.a.sun@intel.com>
+Signed-off-by: ZhiZhen Tang <zhizhen.tang@intel.com>
+Signed-off-by: Zhong Li <zhong.li@intel.com>
+---
+ configure               |   4 +
+ libavcodec/Makefile     |   1 +
+ libavcodec/allcodecs.c  |   1 +
+ libavcodec/libsvt_av1.c | 533 ++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 539 insertions(+)
+ create mode 100644 libavcodec/libsvt_av1.c
+
+diff --git a/configure b/configure
+index 34c2adb..e05f3a5 100755
+--- a/configure
++++ b/configure
+@@ -264,6 +264,7 @@ External library support:
+   --enable-libspeex        enable Speex de/encoding via libspeex [no]
+   --enable-libsrt          enable Haivision SRT protocol via libsrt [no]
+   --enable-libssh          enable SFTP protocol via libssh [no]
++  --enable-libsvtav1       enable AV1 encoding via svt [no]
+   --enable-libtensorflow   enable TensorFlow as a DNN module backend
+                            for DNN based filters like sr [no]
+   --enable-libtesseract    enable Tesseract, needed for ocr filter [no]
+@@ -1793,6 +1794,7 @@ EXTERNAL_LIBRARY_LIST="
+     libspeex
+     libsrt
+     libssh
++    libsvtav1
+     libtensorflow
+     libtesseract
+     libtheora
+@@ -3191,6 +3193,7 @@ libshine_encoder_select="audio_frame_queue"
+ libspeex_decoder_deps="libspeex"
+ libspeex_encoder_deps="libspeex"
+ libspeex_encoder_select="audio_frame_queue"
++libsvt_av1_encoder_deps="libsvtav1"
+ libtheora_encoder_deps="libtheora"
+ libtwolame_encoder_deps="libtwolame"
+ libvo_amrwbenc_encoder_deps="libvo_amrwbenc"
+@@ -6263,6 +6266,7 @@ enabled libsoxr           && require libsoxr soxr.h soxr_create -lsoxr
+ enabled libssh            && require_pkg_config libssh libssh libssh/sftp.h sftp_init
+ enabled libspeex          && require_pkg_config libspeex speex speex/speex.h speex_decoder_init
+ enabled libsrt            && require_pkg_config libsrt "srt >= 1.3.0" srt/srt.h srt_socket
++enabled libsvtav1         && require_pkg_config libsvtav1 SvtAv1Enc EbSvtAv1Enc.h eb_init_handle
+ enabled libtensorflow     && require libtensorflow tensorflow/c/c_api.h TF_Version -ltensorflow
+ enabled libtesseract      && require_pkg_config libtesseract tesseract tesseract/capi.h TessBaseAPICreate
+ enabled libtheora         && require libtheora theora/theoraenc.h th_info_init -ltheoraenc -ltheoradec -logg
+diff --git a/libavcodec/Makefile b/libavcodec/Makefile
+index 3cd73fb..5db4565 100644
+--- a/libavcodec/Makefile
++++ b/libavcodec/Makefile
+@@ -991,6 +991,7 @@ OBJS-$(CONFIG_LIBOPUS_ENCODER)            += libopusenc.o libopus.o     \
+ OBJS-$(CONFIG_LIBSHINE_ENCODER)           += libshine.o
+ OBJS-$(CONFIG_LIBSPEEX_DECODER)           += libspeexdec.o
+ OBJS-$(CONFIG_LIBSPEEX_ENCODER)           += libspeexenc.o
++OBJS-$(CONFIG_LIBSVT_AV1_ENCODER)         += libsvt_av1.o
+ OBJS-$(CONFIG_LIBTHEORA_ENCODER)          += libtheoraenc.o
+ OBJS-$(CONFIG_LIBTWOLAME_ENCODER)         += libtwolame.o
+ OBJS-$(CONFIG_LIBVO_AMRWBENC_ENCODER)     += libvo-amrwbenc.o
+diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
+index d2f9a39..75759c7 100644
+--- a/libavcodec/allcodecs.c
++++ b/libavcodec/allcodecs.c
+@@ -707,6 +707,7 @@ extern AVCodec ff_librsvg_decoder;
+ extern AVCodec ff_libshine_encoder;
+ extern AVCodec ff_libspeex_encoder;
+ extern AVCodec ff_libspeex_decoder;
++extern AVCodec ff_libsvt_av1_encoder;
+ extern AVCodec ff_libtheora_encoder;
+ extern AVCodec ff_libtwolame_encoder;
+ extern AVCodec ff_libvo_amrwbenc_encoder;
+diff --git a/libavcodec/libsvt_av1.c b/libavcodec/libsvt_av1.c
+new file mode 100644
+index 0000000..7bed66c
+--- /dev/null
++++ b/libavcodec/libsvt_av1.c
+@@ -0,0 +1,533 @@
++/*
++* Scalable Video Technology for AV1 encoder library plugin
++*
++* Copyright (c) 2018 Intel Corporation
++*
++* This file is part of FFmpeg.
++*
++* FFmpeg is free software; you can redistribute it and/or
++* modify it under the terms of the GNU Lesser General Public
++* License as published by the Free Software Foundation; either
++* version 2.1 of the License, or (at your option) any later version.
++*
++* FFmpeg is distributed in the hope that it will be useful,
++* but WITHOUT ANY WARRANTY; without even the implied warranty of
++* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++* Lesser General Public License for more details.
++*
++* You should have received a copy of the GNU Lesser General Public
++* License along with this program; if not, write to the Free Software
++* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++*/
++
++#include <stdint.h>
++#include "EbSvtAv1ErrorCodes.h"
++#include "EbSvtAv1Enc.h"
++
++#include "libavutil/common.h"
++#include "libavutil/frame.h"
++#include "libavutil/opt.h"
++#include "libavutil/pixdesc.h"
++#include "libavutil/avassert.h"
++
++#include "internal.h"
++#include "avcodec.h"
++
++typedef enum eos_status {
++    EOS_NOT_REACHED = 0,
++    EOS_SENT,
++    EOS_RECEIVED
++}EOS_STATUS;
++
++typedef struct SvtContext {
++    AVClass     *class;
++
++    EbSvtAv1EncConfiguration    enc_params;
++    EbComponentType            *svt_handle;
++
++    EbBufferHeaderType         *in_buf;
++    int                         raw_size;
++
++    EOS_STATUS eos_flag;
++
++    // User options.
++    int hierarchical_level;
++    int la_depth;
++    int enc_mode;
++    int rc_mode;
++    int scd;
++    int qp;
++
++    int forced_idr;
++
++    int tier;
++    int level;
++    int profile;
++
++    int base_layer_switch_mode;
++    int thread_count;
++} SvtContext;
++
++static const struct {
++    EbErrorType    eb_err;
++    int            av_err;
++    const char     *desc;
++} svt_errors[] = {
++    { EB_ErrorNone,                             0,              "success"                   },
++    { EB_ErrorInsufficientResources,      AVERROR(ENOMEM),      "insufficient resources"    },
++    { EB_ErrorUndefined,                  AVERROR(EINVAL),      "undefined error"           },
++    { EB_ErrorInvalidComponent,           AVERROR(EINVAL),      "invalid component"         },
++    { EB_ErrorBadParameter,               AVERROR(EINVAL),      "bad parameter"             },
++    { EB_ErrorDestroyThreadFailed,        AVERROR_EXTERNAL,     "failed to destory thread"  },
++    { EB_ErrorSemaphoreUnresponsive,      AVERROR_EXTERNAL,     "semaphore unresponsive"    },
++    { EB_ErrorDestroySemaphoreFailed,     AVERROR_EXTERNAL,     "semaphore unresponsive"    },
++    { EB_ErrorCreateMutexFailed,          AVERROR_EXTERNAL,     "failed to creat mutex"     },
++    { EB_ErrorMutexUnresponsive,          AVERROR_EXTERNAL,     "mutex unresponsive"        },
++    { EB_ErrorDestroyMutexFailed,         AVERROR_EXTERNAL,     "failed to destory muxtex"  },
++    { EB_NoErrorEmptyQueue,               AVERROR(EAGAIN),      "empty queue"               },
++};
++
++static int svt_map_error(EbErrorType eb_err, const char **desc)
++{
++    int i;
++
++    av_assert0(desc);
++    for (i = 0; i < FF_ARRAY_ELEMS(svt_errors); i++) {
++        if (svt_errors[i].eb_err == eb_err) {
++            *desc = svt_errors[i].desc;
++            return svt_errors[i].av_err;
++        }
++    }
++    *desc = "unknown error";
++    return AVERROR_UNKNOWN;
++}
++
++static int svt_print_error(void *log_ctx, EbErrorType err,
++                           const char *error_string)
++{
++    const char *desc;
++    int ret;
++    ret = svt_map_error(err, &desc);
++    av_log(log_ctx, AV_LOG_ERROR, "%s: %s (0x%x)\n", error_string, desc, err);
++    return ret;
++}
++
++static void free_buffer(SvtContext *svt_enc)
++{
++    if (svt_enc->in_buf) {
++        EbSvtIOFormat *in_data = (EbSvtIOFormat *)svt_enc->in_buf->p_buffer;
++        av_freep(&in_data);
++        av_freep(&svt_enc->in_buf);
++    }
++}
++
++static int alloc_buffer(EbSvtAv1EncConfiguration *config, SvtContext *svt_enc)
++{
++    const int    pack_mode_10bit   =
++        (config->encoder_bit_depth > 8) && (config->compressed_ten_bit_format == 0) ? 1 : 0;
++    const size_t luma_size_8bit    =
++        config->source_width * config->source_height * (1 << pack_mode_10bit);
++    const size_t luma_size_10bit   =
++        (config->encoder_bit_depth > 8 && pack_mode_10bit == 0) ? luma_size_8bit : 0;
++
++    EbSvtIOFormat *in_data;
++
++    svt_enc->raw_size = (luma_size_8bit + luma_size_10bit) * 3 / 2;
++
++    // allocate buffer for in and out
++    svt_enc->in_buf           = av_mallocz(sizeof(*svt_enc->in_buf));
++    if (!svt_enc->in_buf)
++        return AVERROR(ENOMEM);
++
++    in_data  = av_mallocz(sizeof(*in_data));
++    if (!in_data)
++        return AVERROR(ENOMEM);
++    svt_enc->in_buf->p_buffer  = (unsigned char *)in_data;
++
++    svt_enc->in_buf->size        = sizeof(*svt_enc->in_buf);
++    svt_enc->in_buf->p_app_private  = NULL;
++
++    return 0;
++
++}
++
++static int config_enc_params(EbSvtAv1EncConfiguration *param,
++                             AVCodecContext *avctx)
++{
++    SvtContext *svt_enc = avctx->priv_data;
++    const AVPixFmtDescriptor *desc;
++    int ret;
++
++    param->source_width     = avctx->width;
++    param->source_height    = avctx->height;
++
++    desc = av_pix_fmt_desc_get(avctx->pix_fmt);
++    param->encoder_bit_depth = desc->comp[0].depth;
++    av_log(avctx, AV_LOG_DEBUG , "Encoder %d bits depth input\n", param->encoder_bit_depth);
++
++    if (desc->log2_chroma_w == 1 && desc->log2_chroma_h == 1)
++        param->encoder_color_format   = EB_YUV420;
++    else if (desc->log2_chroma_w == 1 && desc->log2_chroma_h == 0)
++        param->encoder_color_format   = EB_YUV422;
++    else if (!desc->log2_chroma_w && !desc->log2_chroma_h)
++        param->encoder_color_format   = EB_YUV444;
++    else {
++        av_log(avctx, AV_LOG_ERROR , "Unsupported pixel format\n");
++        return AVERROR(EINVAL);
++    }
++    av_log(avctx, AV_LOG_DEBUG , "Encoder color format is %d \n", param->encoder_color_format);
++
++    param->profile = svt_enc->profile;
++
++    if ((param->encoder_color_format == EB_YUV422 || param->encoder_bit_depth > 10)
++         && param->profile != PROFESSIONAL_PROFILE ) {
++        av_log(avctx, AV_LOG_WARNING, "Force to be professional profile \n");
++        param->profile = PROFESSIONAL_PROFILE;
++    } else if (param->encoder_color_format == EB_YUV444 && param->profile != HIGH_PROFILE) {
++        av_log(avctx, AV_LOG_WARNING, "Force to be high profile \n");
++        param->profile = HIGH_PROFILE;
++    }
++
++    // Update param from options
++    param->hierarchical_levels     = svt_enc->hierarchical_level;
++    param->enc_mode                = svt_enc->enc_mode;
++    param->tier                   = svt_enc->tier;
++    param->level                  = svt_enc->level;
++    param->rate_control_mode        = svt_enc->rc_mode;
++    param->scene_change_detection   = svt_enc->scd;
++    param->base_layer_switch_mode    = svt_enc->base_layer_switch_mode;
++    param->qp                     = svt_enc->qp;
++
++
++    param->target_bit_rate          = avctx->bit_rate;
++    if (avctx->gop_size > 0)
++        param->intra_period_length  = avctx->gop_size - 1;
++
++    if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {
++        param->frame_rate_numerator     = avctx->framerate.num;
++        param->frame_rate_denominator   = avctx->framerate.den * avctx->ticks_per_frame;
++    } else {
++        param->frame_rate_numerator     = avctx->time_base.den;
++        param->frame_rate_denominator   = avctx->time_base.num * avctx->ticks_per_frame;
++    }
++
++    if (param->rate_control_mode) {
++        param->max_qp_allowed       = avctx->qmax;
++        param->min_qp_allowed       = avctx->qmin;
++    }
++
++    param->intra_refresh_type       = svt_enc->forced_idr + 1;
++
++    if (svt_enc->la_depth != -1)
++        param->look_ahead_distance  = svt_enc->la_depth;
++
++    if ((svt_enc->thread_count > 0) &&
++        (svt_enc->thread_count < (EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_FACTOR))) {
++        param->threadCount = EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_FACTOR;
++        av_log(avctx, AV_LOG_WARNING, "Thread count is set too small, forced to %"PRId32"\n",
++               param->threadCount);
++    } else if (svt_enc->thread_count % EB_THREAD_COUNT_MIN_CORE) {
++        param->threadCount = (svt_enc->thread_count + EB_THREAD_COUNT_MIN_CORE - 1)
++                             / EB_THREAD_COUNT_MIN_CORE * EB_THREAD_COUNT_MIN_CORE;
++        av_log(avctx, AV_LOG_DEBUG, "Thread count is rounded to %"PRId32"\n",
++               param->threadCount);
++    } else {
++        param->threadCount = svt_enc->thread_count;
++    }
++
++    return 0;
++}
++
++static void read_in_data(const AVFrame *frame,
++                         EbBufferHeaderType *header_ptr)
++{
++    EbSvtIOFormat *in_data = (EbSvtIOFormat *)header_ptr->p_buffer;
++    const AVPixFmtDescriptor *desc;
++    int i, bytes_shift, plane_h;
++
++    desc = av_pix_fmt_desc_get(frame->format);
++    bytes_shift = desc->comp[0].depth > 8 ? 1 : 0;
++
++    in_data->luma = frame->data[0];
++    in_data->cb   = frame->data[1];
++    in_data->cr   = frame->data[2];
++
++    in_data->y_stride  = AV_CEIL_RSHIFT(frame->linesize[0], bytes_shift);
++    in_data->cb_stride = AV_CEIL_RSHIFT(frame->linesize[1], bytes_shift);
++    in_data->cr_stride = AV_CEIL_RSHIFT(frame->linesize[2], bytes_shift);
++
++    for (i = 0; i < desc->nb_components; i++) {
++        plane_h = frame->height;
++        if (i > 0)
++            plane_h = AV_CEIL_RSHIFT(plane_h, desc->log2_chroma_h);
++        header_ptr->n_filled_len += frame->linesize[i] * plane_h;
++    }
++}
++
++static av_cold int eb_enc_init(AVCodecContext *avctx)
++{
++    SvtContext   *svt_enc = avctx->priv_data;
++    EbErrorType svt_ret;
++    int ret;
++
++    svt_enc->eos_flag = EOS_NOT_REACHED;
++
++    svt_ret = eb_init_handle(&svt_enc->svt_handle, svt_enc, &svt_enc->enc_params);
++    if (svt_ret != EB_ErrorNone) {
++        return svt_print_error(avctx, svt_ret, "Error init encoder handle");
++    }
++
++    ret = config_enc_params(&svt_enc->enc_params, avctx);
++    if (ret < 0) {
++        av_log(avctx, AV_LOG_ERROR, "Error configure encoder parameters\n");
++        return ret;
++    }
++
++    svt_ret = eb_svt_enc_set_parameter(svt_enc->svt_handle, &svt_enc->enc_params);
++    if (svt_ret != EB_ErrorNone) {
++        return svt_print_error(avctx, svt_ret, "Error setting encoder parameters");
++    }
++
++    svt_ret = eb_init_encoder(svt_enc->svt_handle);
++    if (svt_ret != EB_ErrorNone) {
++        eb_deinit_handle(svt_enc->svt_handle);
++        svt_enc->svt_handle = NULL;
++        return svt_print_error(avctx, svt_ret, "Error init encoder");
++    }
++
++    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {
++        EbBufferHeaderType *headerPtr = NULL;
++
++        svt_ret = eb_svt_enc_stream_header(svt_enc->svt_handle, &headerPtr);
++        if (svt_ret != EB_ErrorNone) {
++            return svt_print_error(avctx, svt_ret, "Error when build stream header");
++        }
++
++        avctx->extradata_size = headerPtr->n_filled_len;
++        avctx->extradata = av_mallocz(avctx->extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
++        if (!avctx->extradata) {
++            av_log(avctx, AV_LOG_ERROR,
++                   "Cannot allocate AV1 header of size %d.\n", avctx->extradata_size);
++            return AVERROR(ENOMEM);
++        }
++
++        memcpy(avctx->extradata, headerPtr->p_buffer, avctx->extradata_size);
++
++        svt_ret = eb_svt_release_enc_stream_header(headerPtr);
++        if (svt_ret != EB_ErrorNone) {
++            return svt_print_error(avctx, svt_ret, "Error when destroy stream header");
++        }
++    }
++
++    ret = alloc_buffer(&svt_enc->enc_params, svt_enc);
++    if (ret < 0)
++        return ret;
++    return 0;
++
++}
++
++static int eb_send_frame(AVCodecContext *avctx, const AVFrame *frame)
++{
++    SvtContext           *svt_enc = avctx->priv_data;
++    EbBufferHeaderType  *headerPtr = svt_enc->in_buf;
++
++    if (!frame) {
++        EbBufferHeaderType headerPtrLast;
++        headerPtrLast.n_alloc_len   = 0;
++        headerPtrLast.n_filled_len  = 0;
++        headerPtrLast.n_tick_count  = 0;
++        headerPtrLast.p_app_private = NULL;
++        headerPtrLast.p_buffer     = NULL;
++        headerPtrLast.flags      = EB_BUFFERFLAG_EOS;
++
++        eb_svt_enc_send_picture(svt_enc->svt_handle, &headerPtrLast);
++        svt_enc->eos_flag = EOS_SENT;
++        av_log(avctx, AV_LOG_DEBUG, "Finish sending frames!!!\n");
++        return 0;
++    }
++
++    read_in_data(frame, headerPtr);
++
++    headerPtr->flags       = 0;
++    headerPtr->p_app_private  = NULL;
++    headerPtr->pts          = frame->pts;
++
++    eb_svt_enc_send_picture(svt_enc->svt_handle, headerPtr);
++
++    return 0;
++}
++
++static int eb_receive_packet(AVCodecContext *avctx, AVPacket *pkt)
++{
++    SvtContext  *svt_enc = avctx->priv_data;
++    EbBufferHeaderType *headerPtr;
++    EbErrorType svt_ret;
++    int ret = 0, pict_type;
++
++    if (svt_enc->eos_flag == EOS_RECEIVED)
++        return AVERROR_EOF;
++
++    if ((ret = ff_alloc_packet2(avctx, pkt, svt_enc->raw_size, 0)) < 0) {
++        av_log(avctx, AV_LOG_ERROR, "Failed to allocate output packet.\n");
++        return ret;
++    }
++    svt_ret = eb_svt_get_packet(svt_enc->svt_handle, &headerPtr, svt_enc->eos_flag);
++    if (svt_ret == EB_NoErrorEmptyQueue)
++        return AVERROR(EAGAIN);
++
++    memcpy(pkt->data, headerPtr->p_buffer, headerPtr->n_filled_len);
++    pkt->size = headerPtr->n_filled_len;
++    pkt->pts  = headerPtr->pts;
++    pkt->dts  = headerPtr->dts;
++    if (headerPtr->pic_type == EB_AV1_KEY_PICTURE) {
++        pkt->flags |= AV_PKT_FLAG_KEY;
++        pict_type = AV_PICTURE_TYPE_I;
++    } else if (headerPtr->pic_type == EB_AV1_INTRA_ONLY_PICTURE) {
++        pict_type = AV_PICTURE_TYPE_I;
++    } else if (headerPtr->pic_type == EB_AV1_INVALID_PICTURE) {
++        pict_type = AV_PICTURE_TYPE_NONE;
++    } else
++        pict_type = AV_PICTURE_TYPE_P;
++
++    if (headerPtr->pic_type == EB_AV1_NON_REF_PICTURE)
++        pkt->flags |= AV_PKT_FLAG_DISPOSABLE;
++
++    if (headerPtr->flags & EB_BUFFERFLAG_EOS)
++        svt_enc->eos_flag = EOS_RECEIVED;
++
++    ff_side_data_set_encoder_stats(pkt, headerPtr->qp * FF_QP2LAMBDA, NULL, 0, pict_type);
++
++    eb_svt_release_out_buffer(&headerPtr);
++
++    return ret;
++}
++
++static av_cold int eb_enc_close(AVCodecContext *avctx)
++{
++    SvtContext *svt_enc = avctx->priv_data;
++
++    if (svt_enc) {
++        if (svt_enc->svt_handle) {
++            eb_deinit_encoder(svt_enc->svt_handle);
++            eb_deinit_handle(svt_enc->svt_handle);
++        }
++
++        free_buffer(svt_enc);
++        svt_enc = NULL;
++    }
++    return 0;
++}
++
++#define OFFSET(x) offsetof(SvtContext, x)
++#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
++static const AVOption options[] = {
++    { "hielevel", "Hierarchical prediction levels setting", OFFSET(hierarchical_level),
++      AV_OPT_TYPE_INT, { .i64 = 4 }, 3, 4, VE , "hielevel"},
++        { "3level", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 3 },  INT_MIN, INT_MAX, VE, "hielevel" },
++        { "4level", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 4 },  INT_MIN, INT_MAX, VE, "hielevel" },
++
++    { "la_depth", "Look ahead distance [0, 120]", OFFSET(la_depth),
++      AV_OPT_TYPE_INT, { .i64 = -1 }, -1, 120, VE },
++
++    { "preset", "Encoding preset [0, 8]",
++      OFFSET(enc_mode), AV_OPT_TYPE_INT, { .i64 = MAX_ENC_PRESET }, 0, MAX_ENC_PRESET, VE },
++
++    { "profile", "Set profile restrictions", OFFSET(profile), AV_OPT_TYPE_INT, { .i64 = MAIN_PROFILE}, MAIN_PROFILE, PROFESSIONAL_PROFILE, VE, "profile" },
++    { "main" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = MAIN_PROFILE}, INT_MIN, INT_MAX,     VE, "profile" },
++    { "high" , NULL, 0, AV_OPT_TYPE_CONST, { .i64 = HIGH_PROFILE}, INT_MIN, INT_MAX,     VE, "profile" },
++    { "professional", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = PROFESSIONAL_PROFILE }, INT_MIN, INT_MAX,     VE, "profile" },
++
++    { "tier", "Set tier (general_tier_flag)", OFFSET(tier),
++      AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE, "tier" },
++        { "main", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 }, 0, 0, VE, "tier" },
++        { "high", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 1 }, 0, 0, VE, "tier" },
++
++    { "level", "Set level (level_idc)", OFFSET(level),
++      AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 0x1f, VE, "level" },
++
++#define LEVEL(name, value) name, NULL, 0, AV_OPT_TYPE_CONST, \
++      { .i64 = value }, 0, 0, VE, "level"
++        { LEVEL("2.0", 20) },
++        { LEVEL("2.1", 21) },
++        { LEVEL("2.2", 22) },
++        { LEVEL("2.3", 23) },
++        { LEVEL("3.0", 30) },
++        { LEVEL("3.1", 31) },
++        { LEVEL("3.2", 32) },
++        { LEVEL("3.3", 33) },
++        { LEVEL("4.0", 40) },
++        { LEVEL("4.1", 41) },
++        { LEVEL("4.2", 42) },
++        { LEVEL("4.3", 43) },
++        { LEVEL("5.0", 50) },
++        { LEVEL("5.1", 51) },
++        { LEVEL("5.2", 52) },
++        { LEVEL("5.3", 53) },
++        { LEVEL("6.0", 60) },
++        { LEVEL("6.1", 61) },
++        { LEVEL("6.2", 62) },
++        { LEVEL("6.3", 63) },
++        { LEVEL("7.0", 70) },
++        { LEVEL("7.1", 71) },
++        { LEVEL("7.2", 72) },
++        { LEVEL("7.3", 73) },
++#undef LEVEL
++
++    { "rc", "Bit rate control mode", OFFSET(rc_mode),
++      AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 3, VE , "rc"},
++        { "cqp", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 0 },  INT_MIN, INT_MAX, VE, "rc" },
++        { "vbr", NULL, 0, AV_OPT_TYPE_CONST, { .i64 = 2 },  INT_MIN, INT_MAX, VE, "rc" },
++        { "cvbr", NULL, 0, AV_OPT_TYPE_CONST,{ .i64 = 3 },  INT_MIN, INT_MAX, VE, "rc" },
++
++    { "qp", "QP value for intra frames", OFFSET(qp),
++      AV_OPT_TYPE_INT, { .i64 = 50 }, 0, 63, VE },
++
++    { "sc_detection", "Scene change detection", OFFSET(scd),
++      AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE },
++
++    { "bl_mode", "Random Access Prediction Structure type setting", OFFSET(base_layer_switch_mode),
++      AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE },
++
++    { "forced-idr", "If forcing keyframes, force them as IDR frames.", OFFSET(forced_idr),
++      AV_OPT_TYPE_BOOL,   { .i64 = 0 }, 0, 1, VE },
++
++    { "thread_count", "Number of threads [0: Auto, 96: Min]", OFFSET(thread_count),
++      AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, VE },
++
++    {NULL},
++};
++
++static const AVClass class = {
++    .class_name = "libsvt_av1",
++    .item_name  = av_default_item_name,
++    .option     = options,
++    .version    = LIBAVUTIL_VERSION_INT,
++};
++
++static const AVCodecDefault eb_enc_defaults[] = {
++    { "b",         "7M"    },
++    { "g",         "-2"    },
++    { "qmin",      "0"     },
++    { "qmax",      "63"    },
++    { NULL },
++};
++
++AVCodec ff_libsvt_av1_encoder = {
++    .name           = "libsvt_av1",
++    .long_name      = NULL_IF_CONFIG_SMALL("SVT-AV1(Scalable Video Technology for AV1) encoder"),
++    .priv_data_size = sizeof(SvtContext),
++    .type           = AVMEDIA_TYPE_VIDEO,
++    .id             = AV_CODEC_ID_AV1,
++    .init           = eb_enc_init,
++    .send_frame     = eb_send_frame,
++    .receive_packet = eb_receive_packet,
++    .close          = eb_enc_close,
++    .capabilities   = AV_CODEC_CAP_DELAY,
++    .pix_fmts       = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P,
++                                                    AV_PIX_FMT_YUV420P10,
++                                                    AV_PIX_FMT_NONE },
++    .priv_class     = &class,
++    .defaults       = eb_enc_defaults,
++    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
++    .wrapper_name   = "libsvt_av1",
++};
+-- 
+2.17.1
+
-- 
1.8.3.1

